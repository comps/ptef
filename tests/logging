#!/bin/bash

. testlib.sh


function mkfile {
	make_var_printer PTEF_LOGS "$@"
	echo 'echo "stderr output" >&2'
}


# Test that an unset PTEF_LOGS results in a 'logs' subdir in CWD
function notset_file {
	mkfile > executable
	chmod +x executable
	assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'unset\n' exec_log
	[ -d logs ]
	[ -f logs/executable.log ]
	assert_contents $'stderr output\n' logs/executable.log
}
function notset_dir {
	mkdir subd
	mkfile > subd/ptef-runner
	chmod +x subd/ptef-runner
	assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'unset\n' subd/exec_log
	[ -d logs ]
	[ -f logs/subd.log ]
	assert_contents $'stderr output\n' logs/subd.log
}

# Test that an empty PTEF_LOGS is treated as unset
function empty_file {
	mkfile > executable
	chmod +x executable
	PTEF_LOGS= assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'\n' exec_log
	[ -d logs ]
	[ -f logs/executable.log ]
	assert_contents $'stderr output\n' logs/executable.log
}
function empty_dir {
	mkdir subd
	mkfile > subd/ptef-runner
	chmod +x subd/ptef-runner
	PTEF_LOGS= assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'\n' subd/exec_log
	[ -d logs ]
	[ -f logs/subd.log ]
	assert_contents $'stderr output\n' logs/subd.log
}

# Test that PTEF_LOGS is used and works with absolute paths
function absolute_file {
	mkfile > executable
	chmod +x executable
	mkdir testlogs
	PTEF_LOGS="$PWD/testlogs" assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents "$PWD/testlogs"$'\n' exec_log
	[ ! -d logs ]
	[ -f testlogs/executable.log ]
	assert_contents $'stderr output\n' testlogs/executable.log
}
function absolute_dir {
	mkdir subd
	mkfile > subd/ptef-runner
	chmod +x subd/ptef-runner
	PTEF_LOGS="$PWD/testlogs" assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents "$PWD/testlogs"$'\n' subd/exec_log
	[ ! -d logs ]
	[ -f testlogs/subd.log ]
	assert_contents $'stderr output\n' testlogs/subd.log
}

# Test that PTEF_LOGS can be relative (and is adjusted according to prefix)
function relative_file {
	mkfile > executable
	chmod +x executable
	mkdir testlogs
	PTEF_LOGS=testlogs assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'testlogs\n' exec_log
	[ ! -d logs ]
	[ -f testlogs/executable.log ]
	assert_contents $'stderr output\n' testlogs/executable.log
}
function relative_dir {
	mkdir subd
	mkfile > subd/ptef-runner
	chmod +x subd/ptef-runner
	PTEF_LOGS=testlogs assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'../testlogs\n' subd/exec_log
	[ ! -d logs ]
	[ -f testlogs/subd.log ]
	assert_contents $'stderr output\n' testlogs/subd.log
}

# Test that path inside PTEF_LOGS is controlled by PTEF_PREFIX and
# is created (like 'mkdir -p') across several levels
function absolute_prefix {
	mkfile > executable
	chmod +x executable
	mkdir testlogs
	PTEF_PREFIX=/a/b/c PTEF_LOGS="$PWD/testlogs" \
		assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents "$PWD/testlogs"$'\n' exec_log
	[ -f testlogs/a/b/c/executable.log ]
	assert_contents $'stderr output\n' testlogs/a/b/c/executable.log
}
function relative_prefix {
	mkfile > executable
	chmod +x executable
	mkdir testlogs
	PTEF_PREFIX=/a/b/c PTEF_LOGS=testlogs \
		assert_ptef_runner > "$tmpdir/runner_out"
	# path to testlogs is based on real fs path, not PTEF_PREFIX
	assert_contents $'testlogs\n' exec_log
	[ -f testlogs/a/b/c/executable.log ]
	assert_contents $'stderr output\n' testlogs/a/b/c/executable.log
}

# Test that the PTEF_LOGS directory itself is mkdir'd
function absolute_mkdir {
	mkfile > executable
	chmod +x executable
	PTEF_LOGS="$PWD/testlogs" assert_ptef_runner > "$tmpdir/runner_out"
	[ -d testlogs ]
}
function relative_mkdir {
	mkfile > executable
	chmod +x executable
	PTEF_LOGS=testlogs assert_ptef_runner > "$tmpdir/runner_out"
	[ -d testlogs ]
}

# Test that a non-existent parent path to PTEF_LOGS location is considered
# an error
function absolute_noent {
	mkfile > executable
	chmod +x executable
	PTEF_LOGS="$PWD/a/b/c/testlogs" \
		ptef-runner >"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || true
	assert_grep 'ptef error .* No such file or directory' "$tmpdir/runner_err"
	[ ! -e a ]
}
function relative_noent {
	mkfile > executable
	chmod +x executable
	PTEF_LOGS="a/b/c/testlogs" \
		ptef-runner >"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || true
	assert_grep 'ptef error .* No such file or directory' "$tmpdir/runner_err"
	[ ! -e a ]
}

# Test that PTEF_PREFIX has no effect on local 'logs' dir (PTEF_LOGS unset)
function local_logs_prefix {
	mkfile > executable
	chmod +x executable
	PTEF_PREFIX=/a/b/c assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'unset\n' exec_log
	[ -d logs ]
	[ -f logs/executable.log ]
	assert_contents $'stderr output\n' logs/executable.log
}

# Test that only stderr is redirected, stdout remains unaltered
function stdio_redir {
	mkfile > executable
	echo 'echo "stdout output"' >> executable
	chmod +x executable
	{
		assert_ptef_runner
	} > "$tmpdir/runner_out"
	assert_grep '^stdout output$' "$tmpdir/runner_out"
	[ -f logs/executable.log ]
	assert_grep '^stderr output$' logs/executable.log

}


+ notset_file
+ notset_dir
+ empty_file
+ empty_dir
+ absolute_file
+ absolute_dir
+ relative_file
+ relative_dir
+ absolute_prefix
+ relative_prefix
+ absolute_mkdir
+ relative_mkdir
# disable this for valgrind due to ptef_mklog() being called after fork(),
# failing and causing exit(1) of the child without proper free() in place,
# which is not a problem in practice, but valgrind still cares
if [ "$TEST_VARIANT" != "valgrind" ]; then
	+ absolute_noent
	+ relative_noent
fi
+ local_logs_prefix
+ stdio_redir


run_tests "$@"
