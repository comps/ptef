#!/bin/bash

. testlib.sh


# Test that parallel runner execution runs all executables at once by doing
# custom locking inside the executables, forcing them to complete in a specific
# predetermined order
function mkparafile {
	local waitfor="$1" setto="$2"
	cat <<-EOF
	#!/bin/bash
	for ((i = 0; i < 1000; i++)); do
		content=\$(<statefile)
		if [ "\$content" = "$waitfor" ]; then
			echo "$setto" > statefile
			exit 0
		fi
		sleep 0.1
	done
	exit 1
	EOF
}
function parallel_jobs {
	# ensure out-of-alpha-order locking
	mkparafile 1 2 > exec_d
	mkparafile 2 3 > exec_e
	mkparafile 3 4 > exec_a
	mkparafile 4 5 > exec_c
	mkparafile 5 6 > exec_f
	mkparafile 6 7 > exec_b
	chmod +x exec_*
	# since the runner executes in alpha order, 4 parallel jobs should
	# be enough:
	# a
	# a b
	# a b c
	# a b c d
	# a b c
	# a b c e
	# a b c
	# b c
	# b
	# b f
	# b
	echo 1 > statefile
	assert_ptef_runner -j 4 > "$tmpdir/runner_out"
	# no need for runner_out order checking; executables do exit 1 if they
	# fail to find expected value within some time
	assert_grep '^PASS[[:space:]]\+/exec_a' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_b' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_c' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_d' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_e' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_f' "$tmpdir/runner_out"
	local final=$(<statefile)
	[ "$final" = "7" ]
}

# Test that the runner passes no extra open file descriptors to executables
# (Expect fd 255 due to the executable being bash)
function open_fds {
	cat > executable <<-EOF
	#!/bin/bash
	exec list-fds > exec_log
	EOF
	chmod +x executable
	assert_ptef_runner > "$tmpdir/runner_out"
	valgrind_fd="${TEST_VALGRIND_FD:+$'\n'$TEST_VALGRIND_FD}"
	assert_contents $'0\n1\n2'"$valgrind_fd" exec_log
}

# Test that the runner emits a RUN result when it runs an executable
# before the executable finishes
function run_before_pass {
	cat > executable <<-EOF
	#!/bin/bash
	cat fifolock >&2
	EOF
	chmod +x executable
	mkfifo fifolock
	PTEF_RUN=1 assert_ptef_runner > "$tmpdir/runner_out" &
	local i=
	for ((i = 0; i < 1000; i++)); do
		[ -s "$tmpdir/runner_out" ] && break
		sleep 0.1
	done
	cp "$tmpdir/runner_out" "$tmpdir/midrun_out"
	echo > fifolock
	wait
	assert_contents $'RUN[\t ]*/executable' "$tmpdir/midrun_out"
	assert_contents $'RUN[\t ]*/executable\nPASS[\t ]*/executable' \
		"$tmpdir/runner_out"
}

# Test that the runner's -i option (and char **ignored functionality) correctly
# ignore files in CWD
function ignored {
	make_arg_printer > exec1
	make_arg_printer > exec2
	chmod +x exec1 exec2
	assert_ptef_runner -i exec1 > "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec1$' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec2$' "$tmpdir/runner_out"
	assert_ptef_runner -i exec1 -i exec2 > "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec1$' "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec2$' "$tmpdir/runner_out"
}

# Test that all ptef-* CLIs support -h (for help)
function cli_help {
	local ret=0
	ptef-runner -h >"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/runner_err" ]
	ret=0
	ptef-report -h >"$tmpdir/report_out" 2>"$tmpdir/report_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/report_err" ]
	ret=0
	ptef-mklog -h >"$tmpdir/mklog_out" 2>"$tmpdir/mklog_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/mklog_err" ]
}

# Test that report/mklog without args exit with error (without segfault)
function cli_noargs {
	local ret=1
	ptef-report >"$tmpdir/report_out" 2>"$tmpdir/report_err" || ret=$?
	[ "$ret" -ne 0 ]
	[ -s "$tmpdir/report_err" ]
	ret=1
	ptef-mklog >"$tmpdir/mklog_out" 2>"$tmpdir/mklog_err" || ret=$?
	[ "$ret" -ne 0 ]
	[ -s "$tmpdir/mklog_err" ]
}


+ parallel_jobs
+ open_fds
+ run_before_pass
+ ignored
case "$TEST_VARIANT" in	cli|valgrind)
	+ cli_help
	+ cli_noargs
	;;
esac


run_tests "$@"
