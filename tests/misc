#!/bin/bash

. testlib.sh


# Test that parallel runner execution runs all executables at once by doing
# custom locking inside the executables, forcing them to complete in a specific
# predetermined order
function mkparafile {
	local waitfor="$1" setto="$2"
	cat <<-EOF
	#!/bin/bash
	for ((i = 0; i < 1000; i++)); do
		content=\$(<statefile)
		if [ "\$content" = "$waitfor" ]; then
			echo "$setto" > statefile
			exit 0
		fi
		sleep 0.1
	done
	exit 1
	EOF
}
function parallel_jobs {
	# ensure out-of-alpha-order locking
	mkparafile 1 2 > exec_d
	mkparafile 2 3 > exec_e
	mkparafile 3 4 > exec_a
	mkparafile 4 5 > exec_c
	mkparafile 5 6 > exec_f
	mkparafile 6 7 > exec_b
	chmod +x exec_*
	# since the runner executes in alpha order, 4 parallel jobs should
	# be enough:
	# a
	# a b
	# a b c
	# a b c d
	# a b c
	# a b c e
	# a b c
	# b c
	# b
	# b f
	# b
	echo 1 > statefile
	assert_ptef_runner -j 4 > "$tmpdir/runner_out"
	# no need for runner_out order checking; executables do exit 1 if they
	# fail to find expected value within some time
	assert_grep '^PASS[[:space:]]\+/exec_a' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_b' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_c' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_d' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_e' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec_f' "$tmpdir/runner_out"
	local final=$(<statefile)
	[ "$final" = "7" ]
}
# Test that extra unused -j jobs correctly wait for the smaller amount of used
# jobs to finish
function parallel_jobs_extrajobs {
	make_arg_printer > exec1
	chmod +x exec1
	assert_ptef_runner -j 5 > "$tmpdir/runner_out"
	assert_contents $'PASS[\t ]*/exec1\n' "$tmpdir/runner_out"
}

# Test that the runner passes no extra open file descriptors to executables
# (Expect fd 255 due to the executable being bash)
function open_fds {
	cat > executable <<-EOF
	#!/bin/bash
	exec list-fds > exec_log
	EOF
	chmod +x executable
	assert_ptef_runner > "$tmpdir/runner_out"
	valgrind_fd="${TEST_VALGRIND_FD:+$'\n'$TEST_VALGRIND_FD}"
	assert_contents $'0\n1\n2'"$valgrind_fd"$'\n' exec_log
}

# Test that the runner emits a RUN result when it runs an executable
# before the executable finishes
function run_before_pass {
	cat > executable <<-EOF
	#!/bin/bash
	cat fifolock >&2
	EOF
	chmod +x executable
	mkfifo fifolock
	PTEF_RUN=1 assert_ptef_runner > "$tmpdir/runner_out" &
	local i=
	for ((i = 0; i < 1000; i++)); do
		[ -s "$tmpdir/runner_out" ] && break
		sleep 0.1
	done
	cp "$tmpdir/runner_out" "$tmpdir/midrun_out"
	echo > fifolock
	wait
	assert_contents $'RUN[\t ]*/executable\n' "$tmpdir/midrun_out"
	assert_contents $'RUN[\t ]*/executable\nPASS[\t ]*/executable\n' \
		"$tmpdir/runner_out"
}

# Test that the runner's -i option (and char **ignored functionality) correctly
# ignore files in CWD
function ignored {
	make_arg_printer > exec1
	make_arg_printer > exec2
	chmod +x exec1 exec2
	assert_ptef_runner -i exec1 > "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec1$' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/exec2$' "$tmpdir/runner_out"
	assert_ptef_runner -i exec1 -i exec2 > "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec1$' "$tmpdir/runner_out"
	assert_nogrep '^PASS[[:space:]]\+/exec2$' "$tmpdir/runner_out"
}

# Test that custom exit-code-to-status mapping is honored
function mkexitfile {
	cat <<-EOF
	#!/bin/bash
	exit $1
	EOF
}
function exit_codes {
	mkexitfile 1 > exec1
	mkexitfile 0 > exec2
	mkexitfile 255 > exec3
	mkexitfile 2 > exec4
	chmod +x exec1 exec2 exec3 exec4
	assert_ptef_runner -x '1:SECOND 0:FIRST 255:TEST ERROR' \
		> "$tmpdir/runner_out"
	assert_grep '^SECOND[[:space:]]\+/exec1$' "$tmpdir/runner_out"
	assert_grep '^FIRST[[:space:]]\+/exec2$' "$tmpdir/runner_out"
	assert_grep '^TEST[[:space:]]\+/exec3$' "$tmpdir/runner_out"
	assert_grep '^ERROR[[:space:]]\+/exec4$' "$tmpdir/runner_out"
}

# Test basic color map sanity for the runner, detailed testing is performed
# in report/color_map
function runner_color_map {
	make_arg_printer > exec1
	chmod +x exec1
	TEST_WRAPPER=ttee \
		assert_ptef_runner -c 'PASS TESTME' > "$tmpdir/runner_out"
	assert_contents $'TESTME[\t ]*/exec1\n' "$tmpdir/runner_out"
}

# Test some of the -x option sanity checking
function assert_runner_error {
	local ret=0
	ptef-runner "$@" >"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || ret=$?
	[ "$ret" -ne 0 ]
	assert_contents '' "$tmpdir/runner_out"
	[ -s "$tmpdir/runner_err" ]
}
function exit_codes_sanity {
	local ret=0
	assert_runner_error -x ''
	assert_runner_error -x 'END'
	assert_runner_error -x 'PASS END'
	assert_runner_error -x ':PASS END'
	assert_runner_error -x '0: END'
	assert_runner_error -x '256:PASS END'
}

# Test that all ptef-* CLIs support -h (for help)
function cli_help {
	local ret=0
	ptef-runner -h >"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/runner_err" ]
	ret=0
	ptef-report -h >"$tmpdir/report_out" 2>"$tmpdir/report_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/report_err" ]
	ret=0
	ptef-mklog -h >"$tmpdir/mklog_out" 2>"$tmpdir/mklog_err" || ret=$?
	[ "$ret" -eq 0 ]
	[ -s "$tmpdir/mklog_err" ]
}

# Test that report/mklog without args exit with error (without segfault)
function cli_noargs {
	local ret=1
	ptef-report >"$tmpdir/report_out" 2>"$tmpdir/report_err" || ret=$?
	[ "$ret" -ne 0 ]
	[ -s "$tmpdir/report_err" ]
	ret=1
	ptef-mklog >"$tmpdir/mklog_out" 2>"$tmpdir/mklog_err" || ret=$?
	[ "$ret" -ne 0 ]
	[ -s "$tmpdir/mklog_err" ]
}


+ parallel_jobs
+ parallel_jobs_extrajobs
+ open_fds
+ run_before_pass
+ ignored
+ exit_codes
case "$TEST_VARIANT" in	cli|valgrind|python)
	+ runner_color_map
	;;
esac
case "$TEST_VARIANT" in	cli|valgrind)
	+ exit_codes_sanity
	+ cli_help
	+ cli_noargs
	;;
esac


run_tests "$@"
