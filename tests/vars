#!/bin/bash

. testlib.sh


function mkfile {
	make_arg_printer "$@"
}


# Other variables (PTEF_PREFIX / PTEF_LOGS / ..) are tested elsewhere


# Test that PTEF_RUN prints out a RUN status
function ptef_run {
	mkfile > executable
	chmod +x executable
	assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'PASS[\t ]*/executable' "$tmpdir/runner_out"
	PTEF_RUN=1 assert_ptef_runner > "$tmpdir/runner_out"
	assert_contents $'RUN[\t ]*/executable\nPASS[\t ]*/executable' \
		"$tmpdir/runner_out"
}
# Test that cli -r option exports PTEF_RUN and the runner honors it
function ptef_run_opt {
	make_var_printer PTEF_RUN > executable
	chmod +x executable
	assert_ptef_runner -r > "$tmpdir/runner_out"
	assert_contents '1' exec_log
	assert_contents $'RUN[\t ]*/executable\nPASS[\t ]*/executable' \
		"$tmpdir/runner_out"
}

# Test that an open file descriptor passed via PTEF_RESULTS_FD receives
# the same results as stdout
function ptef_results_fd {
	mkfile > executable
	chmod +x executable
	exec {test_fd}>"$tmpdir/result_log"
	PTEF_RESULTS_FD="$test_fd" \
		assert_ptef_runner > "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/result_log"
}

# Test that it receives black&white output only, even if stdout gets
# colors
function ptef_results_fd_nocolor {
	local colorpass=$'\e\[1;32mPASS\e\[0m'
	mkfile > executable
	chmod +x executable
	exec {test_fd}>"$tmpdir/result_log"
	TEST_WRAPPER=ttee PTEF_RESULTS_FD="$test_fd" \
		assert_ptef_runner > "$tmpdir/runner_out"
	assert_grep "^$colorpass[[:space:]]\+/executable$" "$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/result_log"
}

# Test that the runner errors out on a closed PTEF_RESULTS_FD
function ptef_results_fd_closed {
	local ret=0
	mkfile > executable
	chmod +x executable
	exec {test_fd}>"$tmpdir/result_log"
	PTEF_RESULTS_FD="12345" ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || ret=$?
	[ "$ret" -ne 0 ]
	assert_grep 'Bad file descriptor' "$tmpdir/runner_err"
}

# Test that PTEF_SILENT correctly silences runner stdout without impacting
# stdout of executables
function ptef_silent {
	cat > executable <<-EOF
	#!/bin/bash
	echo "this is stdout"
	EOF
	chmod +x executable
	PTEF_SILENT=1 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents 'this is stdout' "$tmpdir/runner_out"
}

# Test that cli -s option exports PTEF_SILENT and the runner honors it
function ptef_silent_opt {
	make_var_printer PTEF_SILENT > executable
	echo 'echo "this is stdout"' >> executable
	chmod +x executable
	ptef-runner -s >"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents '1' exec_log
	assert_contents 'this is stdout' "$tmpdir/runner_out"
}

# Test that PTEF_NOLOGS results in executable stderr not being redirected
# and prevents logs from being created
function ptef_nologs {
	cat > executable <<-EOF
	#!/bin/bash
	echo "this is stderr" >&2
	EOF
	chmod +x executable
	PTEF_NOLOGS=1 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/runner_out"
	[ ! -d logs ]
	assert_contents 'this is stderr' "$tmpdir/runner_err"
}

# Test that cli -v option exports PTEF_NOLOGS and the runner honors it
function ptef_nologs_opt {
	make_var_printer PTEF_NOLOGS > executable
	echo 'echo "this is stderr" >&2' >> executable
	chmod +x executable
	ptef-runner -v >"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents '1' exec_log
	assert_contents 'this is stderr' "$tmpdir/runner_err"
}

# Test that PTEF_SHELL makes the runner launch shell and do nothing more
# (Run ptef-runner via timeout, in case it actually spawns interactive shell.)
function ptef_shell {
	mkfile > executable
	chmod +x executable
	# run with arguments shoud ignore PTEF_SHELL
	PTEF_SHELL="/bin/echo" timeout 10 ptef-runner executable \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents $'PASS[\t ]*/executable\n' "$tmpdir/runner_out"
	assert_contents '' "$tmpdir/runner_err"
	# set to a specific value = run that executable
	PTEF_SHELL="/bin/echo" timeout 10 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents $'\n' "$tmpdir/runner_out"
	assert_contents '' "$tmpdir/runner_err"
	# try with relative path
	cat > "$tmpdir/testshell" <<-EOF
	#!/bin/bash
	echo "works"
	EOF
	chmod +x "$tmpdir/testshell"
	local relpath=$(realpath --relative-to=. "$tmpdir/testshell")
	PTEF_SHELL="$relpath" timeout 10 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents $'works\n' "$tmpdir/runner_out"
	assert_contents '' "$tmpdir/runner_err"
	# try non-zero exit code
	local ret=0
	echo "exit 10" >> "$tmpdir/testshell"
	PTEF_SHELL="$relpath" timeout 10 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err" || ret=$?
	assert_contents $'works\n' "$tmpdir/runner_out"
	assert_contents '' "$tmpdir/runner_err"
	[ "$ret" -eq 10 ]
	# check for $SHELL fallback
	PTEF_SHELL=1 SHELL="/bin/echo" timeout 10 ptef-runner \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents $'\n' "$tmpdir/runner_out"
	assert_contents '' "$tmpdir/runner_err"
}

# Test that cli -d option exports PTEF_SHELL and the runner honors it
function ptef_shell_opt {
	# run with args, so that we can actually print out the variable
	make_var_printer PTEF_SHELL > executable
	chmod +x executable
	timeout 10 ptef-runner -d executable \
		>"$tmpdir/runner_out" 2>"$tmpdir/runner_err"
	assert_contents $'1\n' exec_log
}

# Test that PTEF_COLOR controls result color output on both non-terminal
# and terminal-based stdout
function ptef_color {
	mkfile > executable
	chmod +x executable
	local colorpass=$'\e\[1;32mPASS\e\[0m'
	# output to file + no var = no color
	assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/runner_out"
	assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents $'PASS[\t ]*/testname' "$tmpdir/report_out"
	# output to file + var 0 = no color
	PTEF_COLOR=0 assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/runner_out"
	PTEF_COLOR=0 assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents $'PASS[\t ]*/testname' "$tmpdir/report_out"
	# output to file + var 1 = color
	PTEF_COLOR=1 assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep "^$colorpass[[:space:]]\+/executable$" "$tmpdir/runner_out"
	PTEF_COLOR=1 assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents "$colorpass"$'[\t ]*/testname' "$tmpdir/report_out"
	# output to terminal + no var = color
	TEST_WRAPPER=ttee \
		assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep "^$colorpass[[:space:]]\+/executable$" "$tmpdir/runner_out"
	TEST_WRAPPER=ttee \
		assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents "$colorpass"$'[\t ]*/testname' "$tmpdir/report_out"
	# output to terminal + var 0 = no color
	TEST_WRAPPER=ttee PTEF_COLOR=0 \
		assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep '^PASS[[:space:]]\+/executable$' "$tmpdir/runner_out"
	TEST_WRAPPER=ttee PTEF_COLOR=0 \
		assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents $'PASS[\t ]*/testname' "$tmpdir/report_out"
	# output to terminal + var 1 = color
	TEST_WRAPPER=ttee PTEF_COLOR=1 \
		assert_ptef_runner >"$tmpdir/runner_out"
	assert_grep "^$colorpass[[:space:]]\+/executable$" "$tmpdir/runner_out"
	TEST_WRAPPER=ttee PTEF_COLOR=1 \
		assert_ptef_report PASS testname >"$tmpdir/report_out"
	assert_contents "$colorpass"$'[\t ]*/testname' "$tmpdir/report_out"
}


+ ptef_run
+ ptef_run_opt
+ ptef_results_fd
+ ptef_results_fd_nocolor
+ ptef_results_fd_closed
+ ptef_silent
+ ptef_silent_opt
+ ptef_nologs
+ ptef_nologs_opt
+ ptef_shell
+ ptef_shell_opt
+ ptef_color


run_tests "$@"
