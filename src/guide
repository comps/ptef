
- result reporting
  - sanitization of test name (escape special chars, replace newline, etc.)
  - fd0 locking
  - terminal detection, colors
  - TEF_RESULTS_FD

- log creation
  - rotation
  - TEF_LOGS

- path normalization
  - absolute to relative
  - never above CWD
  - sanitization

- MARK result
  - done using alarm(2)
  - make sure any other code is interrupt-safe (ie. waitpid) and re-tries what it was doing
    if interrupted by a signal


# argument-given run:

- argument parsing, coalescing (merging)
  - fairly easy, we care only whether subsequent args share the same toplevel
    - /shared/a/dontcare , /shared/b/dontcare  -->  run /shared with a/dontcare b/dontcare
    - we really need only int index for the first '/' (path normalization cuts off leading root '/')
  - implementation non-trivial, but cleanly possible, copying out elements to a new argv array
  - 'run entry' is called for each argument (or collection of merged ones), any extra arguments passed
- practical implementation
  - save starting index
    - also save ptr to the current sanitized arg - this will be null-terminated later
      and this ptr will represent the shared prefix
  - iterate through arguments
    - compare previous and current
      - use strchr, replace found '/' with '\0' because we'll be passing the second portion later
        - or not, because we can't tell if there's anything valid beyond that '\0',
          ie. if there was never a '/' (last path portion of the arg)
      - feel free to sanitize in place, argv is freely modifiable
        - ie. advance each arg to after the '/', so each arg is directly usable for execve later
    - if they match, advance to the next arg
    - if they don't match
      - use (current idx minus start idx)
      - do fork
      - terminate the range with NULL
        - since the memory is not shared with parent, this is fine (we don't lose next arg in parent)
        - also, this is safe for the last arg as there's always a NULL element in argv after last arg
      - do execve
        - use the initial saved ptr at the beginning as directory-to-execute
          - do normal dir->basename runner lookup
        - use processed array range as arguments

# both run types

- run entry
  - receives any arguments for the entry
  - receives one filename (result of a scandir)
  - if entry is dir
    - look for basename(argv[0]) in the dir, execute it, pass args, fail if cannot
  - else
    - execute the file, pass args, fail if cannot execute

- execute entry
  - always takes executable file from 'run entry', takes arguments
  - does the actual fork + execve, .. or clone(2)
  - gets passed (from parent chain) a list of child pids, to which it adds the forked pid
  - waits (via wait(2)) until any one child exited, records return value to state passed via parent chain
    - probably keep some parent-passed state of int of running jobs
    - before executing anything, do waitpid(2) and collect any zombies, decrementing the jobs cnt
    - right after execution, increment nr. of jobs by 1
    - after execution, check if nr. of jobs is >= max nr of jobs, .. if so, do wait(2) for any pid




- runner features / arguments - bools as unsigned int flags with #defines
  - argv0: string
  - parallel: bool (0)
  - merge_args: bool (1)
  - ignore_files: argv, NULL-terminated
    - for skipping executables/dirs in cwd when running arg-less
  - ..


- warn that readdir(3) is used, which is generally thread-safe,
  but this is not guaranteed by POSIX.1

- look for EINTR of every syscall used, make an INTR-safe wrapper
  for each one of them
  - alarm can interrupt anywhere
  - incl. outside runner, like F_SETLKW in tef-report

- pipe support for tef_mklog (?)
  - instead of creating logfile to be used by runner that called tef_mklog,
    provide writing to log automatically
  - could abstract TEF_DEBUG_OUTPUT functionality so runner doesn't have to care

- bash builtin - try getenv on BASH_ARGV0 to avoid '-a $(basename $0)'
  - bash 5.0 .. :/

- write reasonable perror messages, prefix with 'tef: ', etc.

- optimize with -O2

- clean up includes

- check fox max CLI length, split arguments across runner calls,
  OR document that this is missing
  - add this to TEF.md
  - ACTUALLY this should never happen; we only pass args if parent (user)
    gave us args and, in that case, all our args already must fit within
    the limit, even if we don't merge

- adjust TEF.md to say that invalid (insane) arg must stop arg merging and the
  runner with exit with non-0 without running anything beyond the invalid arg
  **or running anything beyond the bad arg**
  - this greatly simplifies merging algo
  - what about missing executables? .. permission denied?
    - should a runner continue (skip bad) or abort completely ?
  --> leave as-is, skip insane args, make them abort merging, don't exit

  --> document/clarify that runner should, in all cases, skip the failing
      executable, treat it as an error (finish with non-0 in the end),
      and continue on

- adjust TEF.md w.r.t. terminal detection
  - don't check terminal colors, it's really nonstandard
  - simply: if terminal, assume it supports >=16 colors, else no colors


