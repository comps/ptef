

- MARK result
  - done using alarm(2)
  - make sure any other code is interrupt-safe (ie. waitpid) and re-tries what it was doing
    if interrupted by a signal



- warn that readdir(3) is used, which is generally thread-safe,
  but this is not guaranteed by POSIX.1
  - also document thread-safety for all 3 API functions
  - ie. runner is *not* thread safe with itself, but it should be safe to use in a bigger
    threaded program, though note:
    - writes to stdout, locked by F_WRLCK
    - writes to stderr on error, unsafely (not locked)
    - managers forks with PID tracking and will report as error (on stderr)
      any collected children that aren't its own, so DO NOT start any background
      forks that may exit before the runner call finishes
      - thus also do not start more than one instance of the runner in
        a single process
      - the limitation is waitpid() unable to wait for an array of pids

- look for EINTR of every syscall used, make an INTR-safe wrapper
  for each one of them
  - alarm can interrupt anywhere
  - incl. waitpid in runner

- clean up includes

- adjust PTEF.md to say that invalid (insane) arg must stop arg merging and the
  runner with exit with non-0 without running anything beyond the invalid arg
  **or running anything beyond the bad arg**
  - this greatly simplifies merging algo
  - what about missing executables? .. permission denied?
    - should a runner continue (skip bad) or abort completely ?
  --> leave as-is, skip insane args, make them abort merging, don't exit

  --> document/clarify that runner should, in all cases, skip the failing
      executable, treat it as an error (finish with non-0 in the end),
      and continue on

- adjust PTEF.md w.r.t. terminal detection
  - don't check terminal colors, it's really nonstandard
  - simply: if terminal, assume it supports >=16 colors, else no colors

- re-do fd0 handling in PTEF.md
  - use stdout instead of fd 0, rely on executables not being too noisy,
    maybe mention that this stdout result reporting may be unrealiable
    for machine parsing (due to possibly noisy execs)
  - leave PTEF_RESULTS_FD as-is, color-less, for reliable reporting
  - when executing, redirect only stderr to log, leave stdout on console

- add to PTEF.md a section mentioning RFC2119 (must, should, etc. language)
  - Background & Rationale
  - The Core Idea
    - any executable can be a runner
  - Argument-less and argument-given run
    - path specification, examples, path merging
  - ...
  - Big "examples.md" document
    - passing parameters to executable via a trailing /something
    - one executable reporting multiple results
    - virtual hierarchies, LTP, ...
    - writing custom runners using the building blocks
      - ie. runners that always skip 'setup' 'run' 'cleanup' minus their own
        argv0

- when rewriting PTEF.md, aim it at somebody actually implementing it
  - section for runner, section for report, section for mklog
  - specify only the minimum required functionality
    - ie. don't mention colors for report at all, only "one or more whitespaces"
      between status and test name
  - then add the extra stuff in additional per-feature section(s)
    - ie. automatic use of color if a terminal is detected, can be overriden
      with PTEF_COLOR

- note for parallel execution - what about argument merging?
  - should 'a/b a/c' run a twice wi 'b' and 'c' ?
  - should merging be always disabled for parallel exec?
  - should a new parallel job start only if the currently-examined
    executable is != from the already running?
    - would limit each exec to only one instance
  - can we combine them?
    - if merging is disabled, run multiple jobs even for the same exec
    - if merging is enabled, run one job with multiple args for the one exec

- mention in PTEF.md that PTEF_LOGS directory:
  - MUST be created if it doesn't exist
  - its parents SHOULD NOT be created (error condition caused instead)
  - paths inside PTEF_LOGS however SHOULD be created incl. parents
    - so that parent runners don't have to support log creation

- mention in PTEF.md that a non-empty PTEF_PREFIX must start with a '/'

- mention in PTEF.md (or elsewhere) that runner implementations should not
  use the PTEF_* env variable namespace for out-of-spec features as this
  may lead to name clashes with future spec versions

- mention in PTEF.md that log rotation should go from .log to .1.log,
  without .0.log
  - also mention that the rotated logs must use only a single digit

- adjust PTEF.md - do not propagate failures upwards
  - as a runner, if an executable fails, only record the FAIL result,
    do not exit with non-zero
  - exit with non-zero only if the logic internal to the runner fails
    (ie. command not found)
  - provide rationale in Rationale.md
    - propagating requires extra boilerplate code - tracking overall
      failed=1 state
    - propagating provides little real value - yes, external logic can
      check exit code of the topmost runner, but it might as well grep
      result.log for ^FAIL
      - relying on fail propagation is bug-prone; a runner might fail to
        exit non-0 due to it being a rare condition, causing the whole
        run to be considered successful despite FAILs in result.log
    - reporting runner status separately (via exit code) lets us
      differentiate between failure in the runner itself (maybe it has
      its own test code) and any sub-runners
      - this could also be done by ie. an ERROR status (exit code 2), but
        it would bring extra requirements on exit code into the spec
    - external auto-waiving logic would need to be parent-aware and waive
      any parents of failed children if all children are either PASS or
      have known issues
      - this again makes us unable to distinguish a genuine FAIL in the
        parent runner logic and a FAIL due to one of its children FAILing

- add example showing how to post-process results
  - see ospp-kickstart-test-suite

- mention in PTEF.md that symbolic links should always be followed
  - both symlinks to executable files *and* symlinks to subdirectories

- mention in PTEF.md that result readers MUST be able to deal with unknown
  statuses like RUN, SKIP, WAIVE, etc. (ignoring / skipping them if they're
  not interesting to the reader)
  - they MUST NOT consider unknown status an error

- document zero-length arg in PTEF.md
  - specifying /some/test/ will run 'test' with one empty "" argument
    whereas /some/test will pass no arguments
  - if 'test' is a runner, it should execute no tests, it should not
    default to executing all tests
  - useful for testing a parent execution chain without actually running
    anything in the leaf directory

- PTEF_IGNORE_FILES, newline-separated
  - document it in PTEF.md
    - mention that this list extends the argv0 basename ignore to additional
      executable names
  - this makes more sense if the use case is to ignore 'build' and 'cleanup'
    executables while doing 'run'
  - it's file names, incl. special files - directories
    - ie. 'foo' in 'foo/run' for subrunners
  - ONLY for arg-less operation

- PTEF_COLOR
  - unset or empty: auto, 0: never, 1: always
  - document in PTEF.md

- PTEF_NOLOGS
  - do not create log files, do not redirect stderr
  - useful for debugging as everything will be printed on the console
  - runner must still propagate PTEF_LOGS and adjust to any subrunners
    in case they want to override PTEF_NOLOGS
    - so PTEF_NOLOGS really only prevents .log creation + stderr redirect

- when documenting PTEF.md, show algorithm examples, ie. runner:
    define argv0 as
      basename(argv[0])
    define execute(path,args) as
      if path is directory
        launch path/argv0, passing it args
      else if path is executable regular file
        launch path, passing it args
    if arguments were given
      for each argument, from first to last
        split it into part1,part2 on the first '/' occurence
        do execute(part1,part2)
    else
      for each file in CWD that isn't argv0
        execute(file)

- mention in PTEF.md that a runner MUST have at least 0, 1 and 2
  file descriptors open when being started
  - this is to guarantee dup() above 2
