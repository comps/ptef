

- MARK result
  - done using alarm(2)
  - make sure any other code is interrupt-safe (ie. waitpid) and re-tries what it was doing
    if interrupted by a signal



- warn that readdir(3) is used, which is generally thread-safe,
  but this is not guaranteed by POSIX.1
  - also document thread-safety for all 3 API functions
  - ie. runner is *not* thread safe with itself, but it should be safe to use in a bigger
    threaded program, though note:
    - writes to stdout, locked by F_WRLCK
    - writes to stderr on error, unsafely (not locked)
    - manages forks without PID tracking, so DO NOT start any background
      forks that may exit before the runner call finishes
      - thus also do not start more than one instance of the runner in
        a single process
      - the limitation is waitpid() unable to wait for an array of pids

- look for EINTR of every syscall used, make an INTR-safe wrapper
  for each one of them
  - alarm can interrupt anywhere
  - incl. waitpid in runner

- pipe support for tef_mklog (?)
  - instead of creating logfile to be used by runner that called tef_mklog,
    provide writing to log automatically
  - could abstract TEF_DEBUG_OUTPUT functionality so runner doesn't have to care

- bash builtin - try getenv on BASH_ARGV0 to avoid '-a $(basename $0)'
  - bash 5.0 .. :/

- write reasonable perror messages, prefix with 'tef: ', etc.

- optimize with -O2 and add LTO

- clean up includes

- check fox max CLI length, split arguments across runner calls,
  OR document that this is missing
  - add this to TEF.md
  - ACTUALLY this should never happen; we only pass args if parent (user)
    gave us args and, in that case, all our args already must fit within
    the limit, even if we don't merge

- adjust TEF.md to say that invalid (insane) arg must stop arg merging and the
  runner with exit with non-0 without running anything beyond the invalid arg
  **or running anything beyond the bad arg**
  - this greatly simplifies merging algo
  - what about missing executables? .. permission denied?
    - should a runner continue (skip bad) or abort completely ?
  --> leave as-is, skip insane args, make them abort merging, don't exit

  --> document/clarify that runner should, in all cases, skip the failing
      executable, treat it as an error (finish with non-0 in the end),
      and continue on

- adjust TEF.md w.r.t. terminal detection
  - don't check terminal colors, it's really nonstandard
  - simply: if terminal, assume it supports >=16 colors, else no colors

- re-do fd0 handling in TEF.md
  - use stdout instead of fd 0, rely on executables not being too noisy,
    maybe mention that this stdout result reporting may be unrealiable
    for machine parsing (due to possibly noisy execs)
  - leave TEF_RESULTS_FD as-is, color-less, for reliable reporting
  - when executing, redirect only stderr to log, leave stdout on console
  - TODO fix 'LOOP_FD' hacks in ospp-kickstart-test-suite

- add to TEF.md a section mentioning RFC2119 (must, should, etc. language)
  - Background & Rationale
  - The Core Idea
    - any executable can be a runner
  - Argument-less and argument-given run
    - path specification, examples, path merging
  - ...
  - Big "examples.md" document
    - passing parameters to executable via a trailing /something
    - one executable reporting multiple results
    - virtual hierarchies, LTP, ...
    - writing custom runners using the building blocks
      - ie. runners that always skip 'setup' 'run' 'cleanup' minus their own
        argv0

- note for parallel execution - what about argument merging?
  - should 'a/b a/c' run a twice wi 'b' and 'c' ?
  - should merging be always disabled for parallel exec?
  - should a new parallel job start only if the currently-examined
    executable is != from the already running?
    - would limit each exec to only one instance
  - can we combine them?
    - if merging is disabled, run multiple jobs even for the same exec
    - if merging is enabled, run one job with multiple args for the one exec

- redo bools as integers
  - probably better for ABI
  - also return -1 on error

- rewrite realloc_safe to take void **ptr to be modified in-place
  - return either the new ptr on success, or NULL on fail
  - caller can then choose to free the passed ptr on fail
    or continue on without new element added

- include guards (for multiple-inclusion) in tef.h

- mention in TEF.md that TEF_LOGS directory:
  - MUST be created if it doesn't exist
  - its parents SHOULD NOT be created (error condition caused instead)
  - paths inside TEF_LOGS however SHOULD be created incl. parents
    - so that parent runners don't have to support log creation

- mention in TEF.md that a non-empty TEF_PREFIX must start with a '/'

- mention in TEF.md (or elsewhere) that runner implementations should not
  use the TEF_* env variable namespace for out-of-spec features as this
  may lead to name clashes with future spec versions

- mention in TEF.md that log rotation should go from .log to .1.log,
  without .0.log
  - also mention that the rotated logs must use only a single digit

- adjust TEF.md - do not propagate failures upwards
  - as a runner, if an executable fails, only record the FAIL result,
    do not exit with non-zero
  - exit with non-zero only if the logic internal to the runner fails
    (ie. command not found)
  - provide rationale in Rationale.md
    - propagating requires extra boilerplate code - tracking overall
      failed=1 state
    - propagating provides little real value - yes, external logic can
      check exit code of the topmost runner, but it might as well grep
      result.log for ^FAIL
      - relying on fail propagation is bug-prone; a runner might fail to
        exit non-0 due to it being a rare condition, causing the whole
        run to be considered successful despite FAILs in result.log
    - reporting runner status separately (via exit code) lets us
      differentiate between failure in the runner itself (maybe it has
      its own test code) and any sub-runners
      - this could also be done by ie. an ERROR status (exit code 2), but
        it would bring extra requirements on exit code into the spec
    - external auto-waiving logic would need to be parent-aware and waive
      any parents of failed children if all children are either PASS or
      have known issues
      - this again makes us unable to distinguish a genuine FAIL in the
        parent runner logic and a FAIL due to one of its children FAILing

- add example showing how to post-process results
  - see ospp-kickstart-test-suite

- add example on how to hack/extend reported results
  - ie. add time elapsed for each result
  - since the test name is unparsed string, a suite could easily do custom
    format within the test name field, ie. instead of
      PASS \t /some/test/name \n
    do
      PASS \t 1.567 \t /some/test/name \n
    which is a perfectly valid result as far as TEF is concerned, the
    timestamp is treated as part of the test name
    - though one might need custom tef_report() that doesn't auto-prepend
      TEF_PREFIX
